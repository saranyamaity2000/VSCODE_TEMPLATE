{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"Tree_Diameter_And_MaxDistance": {
		"prefix": "Tree_Diameter_And_MaxDistance",
		"body": [
			"auto bfs = [&](int x) -> pair<int, vector<int>> {",
			"    queue<int> q({x}) ; ",
			"    vector<int> dis(n , -1) ;",
			"    dis[x] = 0 ;",
			"    int u ; ",
			"    while(q.size()){",
			"            u = q.front() ;",
			"            q.pop() ;  ",
			"            for(int v : g[u]){",
			"                if(dis[v] != -1) continue ; ",
			"                q.push(v) ; ",
			"                dis[v] = dis[u] + 1 ; ",
			"            }",
			"    }",
			"    return {u, dis} ; ",
			"};",
			"auto [cand1, _1] = bfs(0) ; ",
			"auto [cand2, d1] = bfs(cand1) ;",
			"auto [_2, d2] = bfs(cand2) ;",
			"// d1 denotes max distance from cand1 to all other node",
			"// d2 denotes max distance from cand2 to all other node",
			"// max of d1 , d2 -> max distance every node has to any other node."
		],
		"description": "Tree_Diameter_And_MaxDistance"
	},
	"haimuri-yesno": {
		"prefix": "haimuri-yesno",
		"body": ["#define hai \"YES\"", "#define muri \"NO\""],
		"description": "haimuri-yesno"
	},
	"debugger-header": {
		"prefix": "debugger-header",
		"body": [
			"#ifndef ONLINE_JUDGE",
			"#include \"/Users/Debug/Debug.h\"",
			"#else",
			"#define debug(...)",
			"#define debugArr(...)",
			"#endif"
		],
		"description": "debugger-header"
	},
	"Trie_DS": {
		"prefix": "Trie_DS",
		"body": [
			"template <int CHARS>",
			"struct Trie{",
			"    struct Node { ",
			"        Node* chars[CHARS];",
			"        int isLeaf;",
			"        Node() {",
			"            for (int i = 0; i<CHARS; i++) chars[i] = NULL;",
			"            isLeaf = 0;",
			"        }",
			"        ~Node() { // can try deleting destructors if TLE but remember can cause MLE",
			"            for (int i = 0; i<CHARS; i++) if(chars[i]) delete chars[i];",
			"        }",
			"    };",
			"    Node* root; ",
			"    Trie(){",
			"        root = new Node();",
			"    }",
			"    ~Trie() {",
			"        delete root;",
			"    }",
			"    bool add(const string &x) {",
			"        Node* t = root;",
			"        for (const char &c : x) {",
			"            int idx = c - '0'; // changable",
			"            if(t->chars[idx] == NULL) {",
			"                t->chars[idx] = new Node();",
			"            }",
			"            t = t->chars[idx];",
			"        }",
			"        t->isLeaf++; ",
			"        return t->isLeaf == 1;",
			"    }",
			"};"
		],
		"description": "Trie_DS"
	},
	"Trie_MinMaxXorAlternative": {
		"prefix": "Trie_MinMaxXorAlternative",
		"body": [
			"template <int CHARS>",
			"struct Trie{",
			"    struct Node { ",
			"        Node* chars[CHARS];",
			"        int isLeaf;",
			"        Node() {",
			"            for (int i = 0; i<CHARS; i++) chars[i] = NULL;",
			"            isLeaf = 0;",
			"        }",
			"        ~Node() { // can try deleting destructors if TLE but remember can cause MLE",
			"            for (int i = 0; i<CHARS; i++) if(chars[i]) delete chars[i];",
			"        }",
			"    };",
			"    Node* root; ",
			"    Trie(){",
			"        root = new Node();",
			"    }",
			"    ~Trie() {",
			"        delete root;",
			"    }",
			"    bool add(const string &x) {",
			"        Node* t = root;",
			"        for (const char &c : x) {",
			"            int idx = c - '0'; // changable",
			"            if(t->chars[idx] == NULL) {",
			"                t->chars[idx] = new Node();",
			"            }",
			"            t = t->chars[idx];",
			"        }",
			"        t->isLeaf++; ",
			"        return t->isLeaf == 1;",
			"    }",
			"    int getMinXorMaker(string x) {",
			"        Node* t = root;",
			"        int minXorMaker = 0; // minXorMaker should have priority on same bits",
			"        for (const char &c : x) {",
			"            int reqBit = c - '0';",
			"            if(t->chars[reqBit]) {",
			"                t = t->chars[reqBit];",
			"                minXorMaker <<= 1;",
			"                minXorMaker ^= reqBit;",
			"            } else {",
			"                t = t->chars[reqBit ^ 1];",
			"                minXorMaker <<= 1;",
			"                minXorMaker ^= (reqBit ^ 1);",
			"            }",
			"        }",
			"        return minXorMaker;",
			"    }",
			"    int getMaxXorMaker(string x) {",
			"        Node* t = root;",
			"        int maxXorMaker = 0; // maxXorMaker should have priority on different bits",
			"        for (const char &c : x) {",
			"            int reqBit = (c - '0') ^ 1;",
			"            if(t->chars[reqBit]) {",
			"                t = t->chars[reqBit];",
			"                maxXorMaker <<= 1;",
			"                maxXorMaker ^= reqBit;",
			"            } else {",
			"                t = t->chars[reqBit ^ 1];",
			"                maxXorMaker <<= 1;",
			"                maxXorMaker ^= (reqBit ^ 1);",
			"            }",
			"        }",
			"        return maxXorMaker;",
			"    }",
			"};"
		],
		"description": "Trie_MinMaxXorAlternative"
	},
	"Dijkstra_Single_Source_Shortest_Path": {
		"prefix": "Dijkstra_Single_Source_Shortest_Path",
		"body": [
			"struct Dijkstra {",
			"    int n;",
			"    const long long inf = 4e18;",
			"    vector<long long> dists; /* for a single run */",
			"    vector<int> parent;",
			"    vector<bool> vis;",
			"    vector<vector<pair<long long, int>>> edges; /* weight, to */",
			"    bool directed ;",
			"    void init(int size, bool dir = false) {",
			"        n = size;",
			"        dists = vector<long long>(n);",
			"        vis = vector<bool>(n);",
			"        parent = vector<int>(n);",
			"        edges = vector<vector<pair<long long, int> > >(n);",
			"        directed = dir ; ",
			"    }",
			"    void addEdge(int a, int b, long long wt) {",
			"        edges[a].emplace_back(wt, b);",
			"        if(not directed) edges[b].emplace_back(wt, a);",
			"    }",
			"    void run(int src) {",
			"        fill(dists.begin(), dists.end(), inf);",
			"        fill(vis.begin(), vis.end(), false);",
			"        fill(parent.begin(), parent.end(), -1);",
			"        priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<>> pq;",
			"        dists[src] = 0;",
			"        pq.emplace(0, src);",
			"        while (!pq.empty()) {",
			"            auto [wt, u] = pq.top();",
			"            pq.pop();",
			"            if (vis[u]) continue;",
			"            vis[u] = 1;",
			"            dists[u] = min(dists[u], wt);",
			"            for (auto& [currWt, v]: edges[u]) {",
			"                long long d = dists[u] + currWt;",
			"                if (d < dists[v]) {",
			"                    dists[v] = d;",
			"                    parent[v] = u;",
			"                    pq.emplace(d, v);",
			"                }",
			"            }",
			"        }",
			"    }",
			"};"
		],
		"description": "Dijkstra_Single_Source_Shortest_Path"
	},
	"coordinate-compression": {
		"prefix": "coordinate-compression",
		"body": [
			"// Generic Helper for Compress built by Glydon ",
			"template<typename T>",
			"struct Compresser",
			"{",
			"    vector<T> originalArray;",
			"    map<T, int> originalToComp;",
			"    vector<T> compToOriginal;",
			"    Compresser(vector<T>& v) {",
			"        this->originalArray = v;",
			"        _compress();",
			"    }",
			"    void _compress() {",
			"        set<T> st(originalArray.begin(), originalArray.end());",
			"        for (auto& x : st) compToOriginal.emplace_back(x);",
			"        int us = compToOriginal.size(); ",
			"        for (int i = 0; i<us; i++)",
			"            originalToComp[compToOriginal[i]] = i;",
			"    }",
			"    T toOriginal(int compValue) {",
			"        assert(compValue >= 0 and compValue < compToOriginal.size());",
			"        return compToOriginal[compValue];",
			"    }",
			"    int toComp(T originalValue) {",
			"        assert(originalToComp.count(originalValue) > 0);",
			"        return originalToComp[originalValue]; ",
			"    }",
			"    int compSize() {",
			"        return compToOriginal.size(); ",
			"    }",
			"};"
		],
		"description": "coordinate-compression"
	},
	"LCA_O1": {
		"prefix": "LCA_O1",
		"body": [
			"template<typename Node>",
			"struct SparseTable {",
			"    vector<vector<Node>> table;",
			"    vector<int> logValues;",
			"    int n;",
			"    int maxLog;",
			"    vector<int> a;",
			"    SparseTable(int n1, vector<int> &arr) {",
			"        n = n1;",
			"        a = arr;",
			"        table.resize(n);",
			"        logValues.resize(n + 1);",
			"        maxLog = log2(n);",
			"        logValues[1] = 0;",
			"        for (int i = 2; i <= n; i++) {",
			"            logValues[i] = logValues[i / 2] + 1;",
			"        }",
			"        for (int i = 0; i < n; i++) {",
			"            table[i].resize(maxLog + 1);",
			"            fill(all(table[i]), Node());",
			"        }",
			"        build();",
			"    }",
			"    void build() {",
			"        for (int i = 0; i < n; i++) {",
			"            table[i][0] = Node(a[i], i);",
			"        }",
			"        for (int i = 1; i <= maxLog; i++) {",
			"            for (int j = 0; (j + (1 << i)) <= n; j++) {",
			"                table[j][i].merge(table[j][i - 1], table[j + (1 << (i - 1))][i - 1]);",
			"            }",
			"        }",
			"    }",
			"    Node queryNormal(int left, int right) {",
			"        Node ans = Node();",
			"        for (int j = logValues[right - left + 1]; j >= 0; j--) {",
			"            if ((1 << j) <= right - left + 1) {",
			"                ans.merge(ans, table[left][j]);",
			"                left += (1 << j);",
			"            }",
			"        }",
			"        return ans;",
			"    }",
			"    Node queryIdempotent(int left, int right) {",
			"        int j = logValues[right - left + 1];",
			"        Node ans = Node();",
			"        ans.merge(table[left][j], table[right - (1 << j) + 1][j]);",
			"        return ans;",
			"    }",
			"};",
			"struct SP_NODE {",
			"    int val; // store more info if required",
			"    int index;",
			"    SP_NODE() { // Identity Element",
			"        val = 1e9;",
			"        index = -1;",
			"    }",
			"    SP_NODE(int v, int ind) {",
			"        val = v;",
			"        index = ind;",
			"    }",
			"    void merge(SP_NODE &l, SP_NODE &r) {",
			"        if(l.val < r.val){",
			"            val = l.val;",
			"            index = l.index;",
			"        }else{",
			"            val = r.val;",
			"            index = r.index;",
			"        }",
			"    }",
			"};",
			"struct LCA_FAST{",
			"    int n;",
			"    vector<int> eulerTour, index;",
			"    vector<int> node;",
			"    SparseTable<SP_NODE> sp = SparseTable<SP_NODE>(0, eulerTour);",
			"    LCA_FAST(int n1, vector<vector<int>> &edges, int root){",
			"        n = n1;",
			"        index.resize(n);",
			"        dfs(root, edges, -1, 0);",
			"        sp = SparseTable<SP_NODE>(eulerTour.size(), eulerTour);",
			"    }",
			"    void dfs(int root, vector<vector<int>> &edges, int parent, int height){",
			"        eulerTour.push_back(height);",
			"        node.push_back(root);",
			"        index[root] = eulerTour.size() - 1;",
			"        for(const auto& i : edges[root]){",
			"            if(i != parent){",
			"                dfs(i, edges, root, height + 1);",
			"                eulerTour.push_back(height);",
			"                node.push_back(root);",
			"            }",
			"        }",
			"    }",
			"    inline int query(int a, int b){",
			"        return node[sp.queryIdempotent(min(index[a], index[b]), max(index[a], index[b])).index];",
			"    }",
			"    inline int getDepth(int a){",
			"        return eulerTour[index[a]];",
			"    }",
			"};"
		],
		"description": "LCA_O1"
	},
	"LCA_LOGN": {
		"prefix": "LCA_LOGN",
		"body": [
			"struct BinaryLifting {",
			"    int n;",
			"    int maxLog;",
			"    ll maxRequirement;",
			"    vector<vector<int>> parent;",
			"    vector<int> logValues;",
			"    bool precomputedLogs = false;",
			"    BinaryLifting(int numberOfNodes, vector<vector<int>> &edges, ll requirement, int root) {",
			"        n = numberOfNodes;",
			"        parent.resize(n);",
			"        maxLog = log2(requirement + 1);",
			"        maxRequirement = requirement;",
			"        for (int i = 0; i < n; i++) {",
			"            parent[i].resize(maxLog + 1);",
			"            for (int j = 0; j <= maxLog; j++) {",
			"                parent[i][j] = -1;",
			"            }",
			"        }",
			"        fillParentTable(root, edges);",
			"        if (maxRequirement <= 1000000LL)",
			"            precomputeLogs();",
			"    }",
			"    void fillParentTable(int root, vector<vector<int>> &edges) {",
			"        vector<bool> visited(n);",
			"        dfsBinaryLifting(root, edges, visited);",
			"        int intermediate = -1;",
			"        for (int i = 1; i <= maxLog; i++) {",
			"            for (int j = 0; j < n; j++) {",
			"                intermediate = parent[j][i - 1];",
			"                if (intermediate != -1) {",
			"                    parent[j][i] = parent[intermediate][i - 1];",
			"                }",
			"            }",
			"        }",
			"    }",
			"    void dfsBinaryLifting(int root, vector<vector<int>> &edges, vector<bool> &visited) {",
			"        visited[root] = true;",
			"        for (auto i : edges[root]) {",
			"            if (!visited[i]) {",
			"                parent[i][0] = root;",
			"                dfsBinaryLifting(i, edges, visited);",
			"            }",
			"        }",
			"    }",
			"    void precomputeLogs() {",
			"        precomputedLogs = true;",
			"        logValues.resize(maxRequirement + 1);",
			"        logValues[1] = 0;",
			"        for (int i = 2; i <= maxRequirement; i++) {",
			"            logValues[i] = logValues[i / 2] + 1;",
			"        }",
			"    }",
			"    int kthParent(int start, int k) {",
			"        int a = start;",
			"        while (k > 0) {",
			"            int x = getLog(k);",
			"            a = parent[a][x];",
			"            if (a == -1)",
			"                return a;",
			"            k -= (1 << x);",
			"        }",
			"        return a;",
			"    }",
			"    inline int getLog(ll x) {",
			"        return precomputedLogs ? logValues[x] : log2(x);",
			"    }",
			"};",
			" ",
			"struct LCA {",
			"    int n;",
			"    vector<int> level;",
			"    LCA(int numberOfNodes, vector<vector<int>> &edges, int root) {",
			"        n = numberOfNodes;",
			"        level.resize(n);",
			"        dfsLCA(root, edges, -1);",
			"    }",
			"    void dfsLCA(int root, vector<vector<int>> &edges, int parent) {",
			"        for (auto i : edges[root]) {",
			"            if (i != parent) {",
			"                level[i] = level[root] + 1;",
			"                dfsLCA(i, edges, root);",
			"            }",
			"        }",
			"    }",
			"    int getLCA(int a, int b, BinaryLifting &bl_object) {",
			"        if (level[a] > level[b]) {",
			"            swap(a, b);",
			"        }",
			"        b = bl_object.kthParent(b, level[b] - level[a]);",
			"        if (a == b)",
			"            return a;",
			"        for (int i = bl_object.maxLog; i >= 0; i--) {",
			"            int parent1 = bl_object.parent[a][i];",
			"            int parent2 = bl_object.parent[b][i];",
			"            if (parent2 != parent1 && parent1 != -1 && parent2 != -1) {",
			"                a = parent1;",
			"                b = parent2;",
			"            }",
			"        }",
			"        return bl_object.parent[a][0];",
			"    }",
			"};"
		],
		"description": "LCA_LOGN"
	},
	"Matrix_Exponentiation": {
		"prefix": "Matrix_Exponentiation",
		"body": [
			"template<typename T>",
			"vector<vector<T>> matrixMultiply( vector<vector<T>>&mat1 , vector<vector<T>>&mat2)",
			"{",
			"    int n = mat1.size(), c1 = mat1[0].size(), c2 = mat2.size(), m = mat2[0].size(); ",
			"    assert (c1 == c2); ",
			"    vector<vector<T>> res(n, vector<T>(n, 0));",
			"    for (int i = 0 ; i<n ; i++) {",
			"        for (int j = 0; j<m ; j++) {",
			"            for (int k = 0; k < c1; k++) {",
			"                res[i][j] += mat1[i][k] * mat2[k][j]; ",
			"            }",
			"        }",
			"    }",
			"    return res;",
			"}",
			"template<typename T>",
			"vector<vector<T>> matrixExpo(vector<vector<T>>&base, ll pow)",
			"{",
			"    int n = base.size();",
			"    assert(n == base[0].size()); ",
			"    vector<vector<T>> res(n, vector<T>(n, 0));",
			"    for(int i = 0; i<n ; i++) res[i][i]=1;",
			"    while(pow > 0)",
			"    {",
			"        if(pow % 2==1) res = matrixMultiply(res, base);",
			"        base = matrixMultiply(base, base);",
			"        pow = pow / 2;",
			"    }",
			"    return res;",
			"}"
		],
		"description": "Matrix_Exponentiation"
	},
	"Mint": {
		"prefix": "Mint",
		"body": [
			"// inspired by Legend LGMs :) ",
			"constexpr int MOD = ${1:998244353};",
			"int fix(int val) {",
			"    if (val < 0) val += MOD; ",
			"    if (val >= MOD) val -= MOD;",
			"    return val;",
			"}",
			"template<class T>",
			"T power(T val, long long pow) {",
			"    T res = 1;",
			"    for (; pow; pow /= 2, val *= val) if (pow % 2) res *= val;",
			"    return res;",
			"}",
			"struct Mint {",
			"    int val;",
			"    Mint(int val = 0) : val(fix(val)) {}",
			"    Mint(long long val) : val(fix(val % MOD)) {}",
			"    int value() const { return val; }",
			"    Mint operator-() const { return Mint(fix(MOD - val)); }",
			"    Mint inv() const { assert(val != 0); return power(*this, MOD - 2); }",
			"    Mint &operator*=(const Mint &rhs) { val = (long long)(val) * rhs.val % MOD; return *this; }",
			"    Mint &operator+=(const Mint &rhs) { val = fix(val + rhs.val); return *this; }",
			"    Mint &operator-=(const Mint &rhs) { val = fix(val - rhs.val); return *this; }",
			"    Mint &operator/=(const Mint &rhs) { return *this *= rhs.inv(); }",
			"    inline friend Mint operator*(const Mint &l, const Mint &r) { Mint res = l; res *= r; return res; }",
			"    inline friend Mint operator+(const Mint &l, const Mint &r) { Mint res = l; res += r; return res; }",
			"    inline friend Mint operator-(const Mint &l, const Mint &r) { Mint res = l; res -= r; return res; }",
			"    inline friend Mint operator/(const Mint &l, const Mint &r) { Mint res = l; res /= r; return res; }",
			"    inline friend istream &operator>>(istream &in, Mint &x) { long long v; in >> v; x = Mint(v); return in; }",
			"    inline friend ostream &operator<<(ostream &out, const Mint &a) { return out << a.value(); }",
			"};",
			"$0"
		],
		"description": "Mint"
	},
	"bits_operation": {
		"prefix": "bits_operation",
		"body": [
			"#define setbits(x) __builtin_popcountll(x)",
			"#define msb(x) (63 - __builtin_clzll(x))"
		],
		"description": "bits_operation"
	},
	"line_operations": {
		"prefix": "line_operations",
		"body": [
			"namespace line_operations {",
			"      using ll = long long; ",
			"      array<ll, 3> lineParameters(const pair<ll, ll> &p1, const pair<ll, ll> &p2){",
			"            ll dx = p1.first - p2.first ;  ",
			"            ll dy = p1.second - p2.second ; ",
			"            ll g = gcd(dx , dy) ; ",
			"            dx /= g , dy /= g ; ",
			"            if(dx < 0 or (dx == 0 and dy < 0)){",
			"                  dx = -dx;",
			"                  dy = -dy;  ",
			"            }",
			"            auto [x, y] = p2;",
			"            ll cdx = y * dx - x * dy ;",
			"            return {dx , dy , cdx} ;",
			"      }",
			"      bool checkPointOnLine(const array<ll, 3> &params, const pair<ll, ll> &p){",
			"            auto [x, y] = p; ",
			"            auto [dx, dy, cdx]  = params;",
			"            return cdx == (y * dx - x * dy) ;",
			"      }",
			"}",
			"using namespace line_operations ;"
		],
		"description": "line_operations"
	},
	"Leetcode-Template": {
		"prefix": "Leetcode_Template",
		"body": [
			"/**",
			" * @author saranyamaity2000",
			" */",
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"#define all(v) (v).begin(), (v).end()",
			"#define forEach(x, v) for (auto x : v)",
			"using ll = long long;",
			"",
			""
		],
		"description": "Leetcode-Template"
	},
	"cp-template": {
		"prefix": "cp-template-cpp",
		"body": [
			"/**",
			" * @author Glydon",
			" * created : $CURRENT_DATE/$CURRENT_MONTH/$CURRENT_YEAR | $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND (IST)",
			" **/",
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"#define cline \"\\n\"",
			"#define all(v) (v).begin(), (v).end()",
			"#define rall(v) (v).rbegin(), (v).rend()",
			"#define ll long long",
			"#define in(x, y, z) ((x <= y) and (y <= z))",
			"#define setbits(x) __builtin_popcountll(x)",
			"#define msb(x) (63 - __builtin_clzll(x)) // msb(x) = log2(x)",
			"template <typename T> istream& operator>>(istream& in, vector<T>& vec) { for (int i = 0; i < vec.size(); i++){ in >> vec[i];}return in;} // author ",
			"template<class P,class D> ostream& operator<<(ostream& out, const pair<P,D>& p){ out << p.first << \" \" << p.second ;return out;}",
			"template <typename T> ostream& operator<<(ostream& out, const vector<T>& vec) { for (const auto& x : vec) { out << x << \" \";} return out;} // is glydon(saranyamaity)",
			"template <typename T> void wr(const T& t) { std::cout << t << std::endl; }",
			"template<typename T, typename... Args> void wr(const T& t, const Args&... args) { std::cout << t << \" \"; wr(args...); }",
			"template<typename T,typename T1>T amax(T &a,T1 b){if(b>a)a=b;return a;}",
			"template<typename T,typename T1>T amin(T &a,T1 b){if(b<a)a=b;return a;}",
			"long long Ceil(long long a, long long b){return (a+b-1)/b;}",
			"long long Sqrt(long long x){ long long y = sqrt(x)+5; while(y*y > x) y--; return y;}",
			"",
			"#ifndef ONLINE_JUDGE",
			"#include \"/Users/Debug/Debug.h\"",
			"#else",
			"#define debug(...)",
			"#define debugArr(...)",
			"#endif",
			"",
			"void solve () {",
			"    $0",
			"}",
			"",
			"signed main() {",
			"    ios_base::sync_with_stdio(false); cin.tie(NULL);",
			"    cout << setprecision(12) << fixed;",
			"    ",
			"    int t = 1;",
			"    ${1:cin >> t ;} ",
			"    for (int i = 1 ; i<= t ; i++) { ",
			"        solve() ; ",
			"    }",
			"    return 0 ; ",
			"}"
		],
		"description": "cp-template"
	},
	"sparse_table": {
		"prefix": "sparse_table",
		"body": [
			"template <typename T, class F = function<T(const T&, const T&)>>",
			"class SparseTable {  ",
			"    private:",
			"    int n;",
			"    vector<vector<T>> dp;",
			"    F Function;",
			"",
			"    public:",
			"    SparseTable(const vector<T>& a, const F& customFunc) : Function(customFunc) {",
			"        n = static_cast<int>(a.size());",
			"        int max_log = 32 - __builtin_clz(n);",
			"        dp.resize(max_log);",
			"        dp[0] = a;",
			"        for (int j = 1; j < max_log; j++) {",
			"            dp[j].resize(n - (1 << j) + 1);",
			"            for (int i = 0; i <= n - (1 << j); i++) {",
			"                dp[j][i] = Function(dp[j - 1][i], dp[j - 1][i + (1 << (j - 1))]);",
			"            }",
			"        }",
			"    }",
			"    T get(int from, int to) const {",
			"        assert(0 <= from && from <= to && to <= n - 1);",
			"        int logVal = 32 - __builtin_clz(to - from + 1) - 1;",
			"        return Function(dp[logVal][from], dp[logVal][to - (1 << logVal) + 1]);",
			"    }",
			"};"
		],
		"description": "sparse_table"
	},

	"pbds-import": {
		"prefix": "pbds-import",
		"body": [
			"#include <ext/pb_ds/assoc_container.hpp> ",
			"#include <ext/pb_ds/tree_policy.hpp>",
			"using namespace __gnu_pbds;",
			"template<class T> using pbset = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update> ;",
			"template<class T> using pbmultiset = tree<T, null_type, less_equal<T>, rb_tree_tag,tree_order_statistics_node_update> ;",
			""
		],
		"description": "pbds-import"
	},
	"Point Update Segment Tree": {
		"prefix": "PointUpdate_Segment_Tree",
		"body": [
			"// Segment Tree with Point Updates and Range Queries",
			"// Supports multiple Segment Trees with just a change in the Node and Update",
			"// SegTree is 1Based Indexing , The Actual Array is 0Based Indexing",
			"template<typename Node, typename Update>",
			"struct SegTree {",
			"    vector<Node> tree;",
			"    vector<long long> arr; // type long long might be changed according to given array ",
			"    // and respectively Update and Node informations should be changed also! ",
			"    int n;",
			"    int s;",
			"    SegTree(int len, vector<long long> &a) { // CHANGE TYPE OF PROVIDED ARRAY IF NEEDED",
			"        arr = a;",
			"        n = len;",
			"        s = 1;",
			"        while(s < 2 * n) s = s << 1;",
			"        tree.assign(s, Node());",
			"        build(1, 0, n - 1);",
			"    }",
			"",
			"    void build(int tIdx, int SI, int EI)  /* DON'T TOUCH IT NORMALLY -_- */",
			"    {",
			"        if (SI == EI)    {",
			"            tree[tIdx] = Node(arr[SI]); // might need to pass more parameters!",
			"            return;",
			"        }",
			"        int mid = (SI + EI) / 2;",
			"        build(2*tIdx, SI, mid);",
			"        build(2*tIdx + 1, mid + 1, EI);",
			"        tree[tIdx].mergeNode(tree[2*tIdx], tree[2*tIdx + 1]);",
			"    }",
			"",
			"    void update(int tIdx, int SI, int EI, int query_index, Update &u)  /* DON'T TOUCH IT NORMALLY -_- */",
			"    {",
			"        if (SI == EI) {",
			"            u.applyUpdate(tree[tIdx]); // might need to pass more parameters!",
			"            return;",
			"        }",
			"        int mid = (SI + EI) / 2;",
			"        if (mid >= query_index)",
			"            update(2*tIdx, SI, mid, query_index, u);",
			"        else",
			"            update(2*tIdx + 1, mid + 1, EI, query_index, u);",
			"        tree[tIdx].mergeNode(tree[2 * tIdx], tree[2 * tIdx + 1]);",
			"    }",
			"",
			"    Node query(int tIdx, int SI, int EI, int left, int right) { /* NEVER TOUCH -_- */",
			"        if (SI > right || EI < left)",
			"            return Node();",
			"        if (SI >= left && EI <= right)",
			"            return tree[tIdx];",
			"        int mid = (SI + EI) / 2;",
			"        Node l, r, ans;",
			"        l = query(2*tIdx, SI, mid, left, right);",
			"        r = query(2*tIdx + 1, mid + 1, EI, left, right);",
			"        ans.mergeNode(l, r);",
			"        return ans;",
			"    }",
			"    ",
			"    void update(int idx, long long val) {  // pass in as many parameters/information as required",
			"        Update new_update = Update(val); // may change according to how the LEAF NODES are affected!",
			"        update(1, 0, n - 1, idx, new_update);",
			"    }",
			"    Node query(int left, int right) {",
			"        return query(1, 0, n - 1, left, right);",
			"    }",
			"};",
			"",
			"struct CustomNode {",
			"    long long val; // may change",
			"    CustomNode() { // Identity element",
			"        val = 0;    // may change",
			"    }",
			"    CustomNode(long long p1) {  // Actual Node",
			"        val = p1; // may change",
			"    }",
			"    void mergeNode(CustomNode &l, CustomNode &r) { // MergeNode two child nodes",
			"        val = l.val ^ r.val;  // may change",
			"    }",
			"};",
			"struct CustomUpdate {",
			"    long long val; // may change / more vars get added  ",
			"    CustomUpdate(long long p1) { // Actual Update ",
			"        val = p1; // may change accordingly",
			"    }",
			"    void applyUpdate(CustomNode &a) { // applyUpdate update to a node ! ",
			"        a.val = val; // may change i.e => a = CustomNode(val) ",
			"        // basically decided how leaf node responds to the current update! ",
			"    }",
			"};"
		],
		"description": "Point Update Segment Tree"
	},
	"Range Update Segment Tree": {
		"prefix": "Lazy_Segment_Tree",
		"body": [
			"/// Credits to Priyansh for the Idea.",
			"// Lazy Segment Tree by Glydon.  ",
			"// default example -> AND mode merges , OR modifications",
			"template<typename Node, typename Update>",
			"struct LazySegTree {",
			"    vector<Node> tree;",
			"    vector<bool> lazy;",
			"    vector<Update> updates;",
			"    vector<long long> arr; // type may change",
			"    int n;",
			"    int s;",
			"    LazySegTree(int a_len, vector<long long> &a) { // change if type updated",
			"        arr = a;",
			"        n = a_len;",
			"        s = 1;",
			"        while(s < 2 * n){s = s << 1;}",
			"        tree.assign(s, Node());",
			"        lazy.assign(s, false);",
			"        updates.assign(s, Update());",
			"        build(1, 0, n - 1);",
			"    }",
			"    void build(int treeIdx, int SI, int EI) { // Never change this",
			"        if (SI == EI)   {",
			"            tree[treeIdx] = Node(arr[SI]);",
			"            return;",
			"        }",
			"        int mid = (SI + EI) / 2;",
			"        build(2*treeIdx, SI, mid);",
			"        build(2*treeIdx + 1, mid + 1, EI);",
			"        tree[treeIdx].mergeNode(tree[2 * treeIdx], tree[2 * treeIdx + 1]);",
			"    }",
			"",
			"    //-------- RELATED --------",
			"    void mergeUpdate(int treeIdx, int SI, int EI, Update& updt){",
			"        lazy[treeIdx] = 1;",
			"        updates[treeIdx].mergeUpdate(updt, SI, EI);",
			"    }",
			"    void pushDownUpdate(int treeIdx, int SI, int EI){ ",
			"        if(SI != EI){",
			"            int mid = (SI + EI) / 2;",
			"            mergeUpdate(2*treeIdx, SI, mid, updates[treeIdx]);",
			"            mergeUpdate(2*treeIdx + 1, mid + 1, EI, updates[treeIdx]);",
			"        }",
			"        updates[treeIdx] = Update();",
			"        lazy[treeIdx] = 0;",
			"    }",
			"    void applyUpdateAndPushDown(int treeIdx , int SI , int EI){",
			"        if(!lazy[treeIdx]) return ; ",
			"        updates[treeIdx].applyUpdateTo(tree[treeIdx], SI, EI);",
			"        pushDownUpdate(treeIdx , SI , EI);",
			"    }",
			"    //------------------------",
			"",
			"    void update(int treeIdx, int SI, int EI, int left, int right, Update& updt) {  ",
			"        if(left <= SI && EI <= right){",
			"            mergeUpdate(treeIdx, SI, EI, updt);",
			"            applyUpdateAndPushDown(treeIdx , SI , EI) ;",
			"        }else{ ",
			"            applyUpdateAndPushDown(treeIdx, SI, EI); // can't leave this hanging ",
			"            // even though range is exclusive because if child doesn't get the update ",
			"            // then currNode might get updated with wrong value! 8 WA to figout :p : p ",
			"            if(SI > right || EI < left) return;",
			"            int mid = (SI + EI) / 2;",
			"            update(2*treeIdx, SI, mid, left, right, updt);",
			"            update(2*treeIdx + 1, mid + 1, EI, left, right, updt);",
			"            tree[treeIdx].mergeNode(tree[2*treeIdx], tree[2*treeIdx + 1]);",
			"        }",
			"    }",
			"",
			"    Node query(int treeIdx, int SI, int EI, int left, int right) { ",
			"        applyUpdateAndPushDown(treeIdx, SI, EI);",
			"        if (SI > right || EI < left)",
			"            return Node();",
			"        if (left <= SI && EI <= right){",
			"            return tree[treeIdx];",
			"        } ",
			"        int mid = (SI + EI) / 2;",
			"        Node l, r, ans;",
			"        l = query(2*treeIdx, SI, mid, left, right);",
			"        r = query(2*treeIdx + 1, mid + 1, EI, left, right);",
			"        ans.mergeNode(l, r);",
			"        return ans;",
			"    }",
			"",
			"    void update(int left, int right, long long val) {  ",
			"        Update updt = Update(val); ",
			"        update(1, 0, n - 1, left, right, updt);",
			"    }",
			"    Node query(int left, int right) {",
			"        return query(1, 0, n - 1, left, right);",
			"    }",
			"};",
			"",
			"struct CustomNode {",
			"    long long val; // may change or need more!",
			"    CustomNode() { // identity (required in SGT constructor and query!)",
			"        val = (1LL << 31) - 1;    ",
			"    }",
			"    CustomNode(long long p1) {  // while creating new leaf node in build!",
			"        val = p1; ",
			"    }",
			"    void mergeNode(CustomNode &l, CustomNode &r) { // merge two nodes!",
			"        val = l.val & r.val;  ",
			"    }",
			"};",
			"",
			"struct CustomUpdate {",
			"    long long val; // may change , can hold more ! CHANGE LINKED things accordingly!",
			"    CustomUpdate(){ // identity update (required in SGT constructor & after pushdown) ",
			"        val = 0;",
			"    }",
			"    CustomUpdate(long long val1) { // required while creating new update ",
			"        val = val1;",
			"    }",
			"    void applyUpdateTo(CustomNode &a, int SI, int EI) {  // applying update accordingly to node a",
			"        a.val |= val ;",
			"    }",
			"    void mergeUpdate(CustomUpdate& new_update, int SI, int EI){ // newUpdate with old update",
			"        val |= new_update.val;",
			"    }",
			"};"
		],
		"description": "Range Update Segment Tree"
	},
	"Fenwick_Tree_BIT": {
		"prefix": "Fenwick_Tree_BIT",
		"body": [
			"template <typename T>",
			"class FenwickTree {",
			"    public:",
			"    vector<T> fenwickTree;",
			"    int n;",
			"    FenwickTree(int _n) : n(_n) {",
			"        fenwickTree.resize(n);",
			"    }",
			"    void modify(int x, T v) {",
			"        while (x < n) {",
			"            fenwickTree[x] += v;",
			"            x |= (x + 1);",
			"        }",
			"    }",
			"    T get(int x) {",
			"        T v{};",
			"        while (x >= 0) {",
			"            v += fenwickTree[x];",
			"            x = (x & (x + 1)) - 1;",
			"        }",
			"        return v;",
			"    }",
			"}; ",
			"struct Node {",
			"    long long val = 0 ; // default value",
			"    Node() {}",
			"    Node(int value) : val(value)  {}",
			"    inline void operator += (Node &other) {",
			"        val = val + other.val;",
			"    }",
			"};"
		],
		"description": "Fenwick_Tree_BIT"
	},
	"Run Length Encoding": {
		"prefix": "run_length_encoding",
		"body": [
			"template<typename T, typename T_iterable>",
			"vector<pair<T, int>> run_length_encoding(const T_iterable &items) {",
			"    vector<pair<T, int>> encoding;",
			"    T previous;",
			"    int count = 0;",
			" ",
			"    for (const T &item : items)",
			"        if (item == previous) {",
			"            count++;",
			"        } else {",
			"            if (count > 0)",
			"                encoding.emplace_back(previous, count);",
			" ",
			"            previous = item;",
			"            count = 1;",
			"        }",
			" ",
			"    if (count > 0)",
			"        encoding.emplace_back(previous, count);",
			" ",
			"    return encoding;",
			"}"
		],
		"description": "Run Length Encoding"
	},
	"Modulo Operations": {
		"prefix": "modop",
		"body": [
			"int64_t MOD = 1e9 + 7;",
			"namespace modop { ",
			"    int64_t madd(int64_t a, int64_t b) {",
			"    return (a + b) % MOD;",
			"    }",
			"    int64_t msub(int64_t a, int64_t b) {",
			"    return (((a - b) % MOD) + MOD) % MOD;",
			"    }",
			"    int64_t mmul(int64_t a, int64_t b) {",
			"    return ((a % MOD) * (b % MOD)) % MOD;",
			"    }",
			"    int64_t mpow(int64_t base, int64_t exp) {",
			"    int64_t res = 1;",
			"    while (exp) {",
			"        if (exp % 2 == 1){",
			"                res = (res * base) % MOD;",
			"        }",
			"        exp >>= 1;",
			"        base = (base * base) % MOD;",
			"    }",
			"    return res;",
			"    }",
			"    int64_t minv(int64_t base) {",
			"    return mpow(base, MOD - 2);",
			"    }",
			"    int64_t mdiv(int64_t a, int64_t b) {",
			"    return mmul(a, minv(b));",
			"    }",
			"    ",
			"    const int64_t FACTORIAL_SIZE = 1.1e6;",
			"    int64_t fact[FACTORIAL_SIZE], ifact[FACTORIAL_SIZE] , derange[FACTORIAL_SIZE];",
			"    bool __factorials_generated__ = 0;",
			"    bool __derange_generated__ = 0;",
			"    void gen_factorial(int64_t n) {",
			"        __factorials_generated__ = 1;",
			"        fact[0] = fact[1] = ifact[0] = ifact[1] = 1;",
			"        ",
			"        for (int64_t i = 2; i <= n; i++) {",
			"                fact[i] = (i * fact[i - 1]) % MOD;",
			"        }",
			"        ifact[n] = minv(fact[n]);",
			"        for (int64_t i = n - 1; i >= 2; i--) {",
			"                ifact[i] = ((i + 1) * ifact[i + 1]) % MOD;",
			"        }",
			"    }",
			"    int64_t nck(int64_t n, int64_t k) {",
			"        if (!__factorials_generated__) {",
			"            cerr << \"Call gen_factorial you dope\" << endl;",
			"            exit(1);",
			"        }",
			"        if (k < 0 || n < k) return 0;",
			"        int64_t den = (ifact[k] * ifact[n - k]) % MOD;",
			"        return (den * fact[n]) % MOD;",
			"    }",
			"    void gen_derange(int64_t n){ // derarange ",
			"        __derange_generated__ = 1 ; ",
			"        derange[1] = derange[0] = 0 ; ",
			"        derange[2] = 1 ;",
			"        for(int64_t i = 3 ; i<n ; i++){",
			"            derange[i] = mmul((i-1),madd(derange[i-2],derange[i-1])) ;  ",
			"        }",
			"    }",
			"}",
			"",
			"using namespace modop;"
		],
		"description": "Modulo Operations"
	},
	"Combinatorics": {
		"prefix": "Combinatorics",
		"body": [
			"struct Combinatorics {",
			"    int limit;",
			"    vector<Mint> _fac;",
			"    vector<Mint> _inv;",
			"    vector<Mint> _invfac;",
			"    Combinatorics() : limit{0}, _fac{1}, _invfac{1}, _inv{0} {}",
			"    Combinatorics(int limit) : Combinatorics() {",
			"        process(limit);",
			"    }",
			"    void process(int newLimit) {",
			"        if (newLimit <= limit) return;",
			"        _fac.resize(newLimit + 1);",
			"        _invfac.resize(newLimit + 1);",
			"        _inv.resize(newLimit + 1);",
			"        ",
			"        for (int i = limit + 1; i <= newLimit; i++) {",
			"            _fac[i] = _fac[i - 1] * i;",
			"        }",
			"        _invfac[newLimit] = _fac[newLimit].inv();",
			"        for (int i = newLimit; i > limit; i--) {",
			"            _invfac[i - 1] = _invfac[i] * i;",
			"            _inv[i] = _invfac[i] * _fac[i - 1];",
			"        }",
			"        limit = newLimit;",
			"    }",
			"    Mint inv(int n) {",
			"        if (n > limit) process(2 * n);",
			"        return _inv[n];",
			"    }",
			"    Mint nCk(int n, int k) {",
			"        if (n < k || k < 0) return 0;",
			"        return fact(n) * ifact(k) * ifact(n - k);",
			"    }   ",
			"    Mint fact(int n) {",
			"        if (n > limit) process(2 * n);",
			"        return _fac[n];",
			"    }",
			"    Mint ifact(int n) {",
			"        if (n > limit) process(2 * n);",
			"        return _invfac[n];",
			"    }",
			"} comb;"
		],
		"description": "Combinatorics"
	},
	"Modulo_Int": {
		"prefix": "Modulo_Int",
		"body": [
			"// credits to Codeforces LGM Jiangly for Template Idea.",
			"constexpr int MOD = ${1:998244353};",
			"",
			"// for normalizing will assume [ -MOD <= val < 2*MOD ]",
			"int normalize(int value) {",
			"    if (value < 0) value += MOD;",
			"    if (value >= MOD) value -= MOD;",
			"    return value;",
			"}",
			"template<class T>",
			"T power(T value, int64_t pow) {",
			"    T res = 1;",
			"    for (; pow; pow /= 2, value *= value)",
			"        if (pow % 2) res *= value;",
			"    return res;",
			"}",
			"struct Mint {",
			"    int value;",
			"    Mint(int value = 0) : value(normalize(value)) {}",
			"    Mint(int64_t value) : value(normalize(value % MOD)) {}",
			"    int val() const {",
			"        return value;",
			"    }",
			"    Mint operator-() const {",
			"        return Mint(normalize(MOD - value));",
			"    }",
			"    Mint inv() const {",
			"        assert(value != 0);",
			"        return power(*this, MOD - 2);",
			"    }",
			"    Mint &operator*=(const Mint &rhs) {",
			"        value = int64_t(value) * rhs.value % MOD;",
			"        return *this;",
			"    }",
			"    Mint &operator+=(const Mint &rhs) {",
			"        value = normalize(value + rhs.value);",
			"        return *this;",
			"    }",
			"    Mint &operator-=(const Mint &rhs) {",
			"        value = normalize(value - rhs.value);",
			"        return *this;",
			"    }",
			"    Mint &operator/=(const Mint &rhs) {",
			"        return *this *= rhs.inv();",
			"    }",
			"    friend Mint operator*(const Mint &l, const Mint &r) {",
			"        Mint res = l; res *= r;",
			"        return res;",
			"    }",
			"    friend Mint operator+(const Mint &l, const Mint &r) {",
			"        Mint res = l; res += r;",
			"        return res;",
			"    }",
			"    friend Mint operator-(const Mint &l, const Mint &r) {",
			"        Mint res = l; res -= r;",
			"        return res;",
			"    }",
			"    friend Mint operator/(const Mint &l, const Mint &r) {",
			"        Mint res = l; res /= r;",
			"        return res;",
			"    }",
			"    friend istream &operator>>(istream &in, Mint &x) {",
			"        int64_t v;",
			"        in >> v;",
			"        x = Mint(v);",
			"        return in;",
			"    }",
			"    friend ostream &operator<<(ostream &out, const Mint &a) {",
			"        return out << a.val();",
			"    }",
			"};$0"
		],
		"description": "modulo int"
	},
	"Disjoin Set Union": {
		"prefix": "dsu_union_find",
		"body": [
			"struct UnionFind {",
			"    vector<int> par; // -ve => par & holds size",
			"    int components ;",
			"    UnionFind(int n = -1) {",
			"        if (n >= 0) reset(n);",
			"    }",
			"    void reset(int n) {",
			"        par.assign(n + 1, -1);",
			"        components = n;",
			"    }",
			"    int find(int x) {",
			"        return par[x] < 0 ? x : par[x] = find(par[x]);",
			"    }",
			"    int getCompSizeOf(int x) {",
			"        return -par[find(x)];",
			"    }",
			"    bool unite(int x, int y) {",
			"        x = find(x);",
			"        y = find(y);",
			"        if (x == y)",
			"            return false;",
			"        if (-par[x] < -par[y])",
			"            swap(x, y);",
			"        par[x] += par[y];",
			"        par[y] = x;",
			"        components--;",
			"        return true;",
			"    }",
			"};"
		],
		"description": "Disjoin Set Union"
	},
	"Interactive-Template": {
		"prefix": "Interactive_Template",
		"body": [
			"/**",
			" * @author Glydon ",
			" * FLAG => -Wmaybe-uninitialized -std=c++20",
			" */",
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"#define cline '\\n'",
			"#define all(v) (v).begin(), (v).end()",
			"using ll = long long;",
			"",
			"",
			"#ifndef ONLINE_JUDGE",
			"#define INTERACTIVE_TESTING true",
			"#else",
			"#define INTERACTIVE_TESTING false",
			"#endif",
			"",
			"class Bot {",
			"    private: ",
			"    int hidden; ",
			"    public: ",
			"    int n;",
			"    void init() {",
			"        hidden = n = randint(1, (int)1000);",
			"    }",
			"    int query(int x) { ",
			"        assert(x);",
			"        return -1; ",
			"    }",
			"    void assertAns(auto& ans) {",
			"        if (INTERACTIVE_TESTING) {",
			"            if (ans == hidden) cout << \"SUCCESS :) \\n\"; ",
			"            else cout << \"FAIL! Expected - \" << hidden << \" , Found - \" << ans << endl ; ",
			"        }",
			"    }",
			"    static int randint(int a , int b) {",
			"        return a + (rand() % (b - a + 1)); ",
			"    }",
			"} bot;",
			"",
			"int query(int q) {",
			"    cout << \"? \" << q << endl;",
			"    int x;",
			"    if (INTERACTIVE_TESTING) {",
			"        x = bot.query(q);",
			"    } else {",
			"        cin >> x;",
			"    }",
			"    return x; ",
			"}",
			"void outputResult(auto& ans){",
			"    cout << \"! \" << ans << endl;",
			"}",
			"",
			"void solve () {",
			"    int n ; // declare input vars;",
			"    if (INTERACTIVE_TESTING) { // take necessary input from bot!",
			"        bot.init();",
			"    } else { // manual general input",
			"    }",
			"    int ans ; ",
			"    bot.assertAns(ans); ",
			"    outputResult(ans); ",
			"}",
			"",
			"int main() {",
			"    srand(time(0));",
			"    ios_base::sync_with_stdio(false) ; ",
			"    cin.tie(NULL); ",
			"    int t = 1;",
			"    cin >> t ; ",
			"    for (int i = 1 ; i<= t ; i++) { ",
			"        solve() ; ",
			"    }",
			"    return 0 ; ",
			"}"
		],
		"description": "Interactive-Template"
	},
	"debugger": {
		"prefix": "debugger_template",
		"body": [
			"string to_string(string str) {return '\"' + str + '\"';}",
			"string to_string(const char* str) {return to_string((string) str);}",
			"string to_string(bool b) {return (b ? \"true\" : \"false\");}",
			"template <typename Item1, typename Item2>",
			"string to_string(pair<Item1, Item2> p) { return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";}",
			"template <typename Iterable>",
			"string to_string(Iterable iterable) {",
			"    bool start = true;",
			"    string output = \"{\";",
			"    for (const auto &x : iterable) {",
			"        if (!start) output += \", \";",
			"        start = false;",
			"        output += to_string(x);",
			"    }",
			"    output += \"}\";",
			"    return output;",
			"}",
			"void debug_cout() { cout << endl; }",
			"template <typename Head, typename... Tail>",
			"void debug_cout(Head H, Tail... T) {cout << \" \" << to_string(H); debug_cout(T...);}",
			"",
			"#ifndef ONLINE_JUDGE",
			"#define debug(...) cout << \"[\" << #__VA_ARGS__ << \"]:\", debug_cout(__VA_ARGS__)",
			"#else",
			"#define debug(...) \"Glydon\"",
			"#endif"
		],
		"description": "debugger"
	},
	"zfunction": {
		"prefix": "zfunction",
		"body": [
			"vector<int> z_function(string s) {",
			"    int n = s.size();",
			"    vector<int> z(n);",
			"    int l = 0, r = 0;",
			"    for(int i = 1; i < n; i++) {",
			"        if(i < r) {",
			"            z[i] = min(r - i, z[i - l]);",
			"        }",
			"        while(i + z[i] < n && s[z[i]] == s[i + z[i]]) {",
			"            z[i]++;",
			"        }",
			"        if(i + z[i] > r) {",
			"            l = i;",
			"            r = i + z[i];",
			"        }",
			"    }",
			"    return z;",
			"}"
		],
		"description": "zfunction"
	},
	"prime_sieve": {
		"prefix": "prime_sieve",
		"body": [
			"vector<int> primes;",
			"vector<bool> isPrime;",
			"const int N = 1000000; // 1e6",
			"void sieve() {",
			"    isPrime.assign(N + 1, true);",
			"    isPrime[0] = isPrime[1] = false; ",
			"    for (int i = 2 ; i<=N; i++) {",
			"        if (isPrime[i]) {",
			"            primes.push_back(i);",
			"            for (int j = 2*i; j<=N; j+=i) {",
			"                isPrime[j] = false;",
			"            }",
			"        }",
			"    }",
			"}",
			"vector<pair<int, int>> getPrimeFactors(int num) {",
			"    if (primes.size() == 0) {",
			"        sieve();",
			"    }",
			"    vector<pair<int, int>> primeCounts;",
			"    for (int& p : primes) {",
			"        if ((long long)p * p > num) break;",
			"        int cnt = 0;",
			"        while (num % p == 0) {",
			"            cnt++; ",
			"            num /= p;",
			"        }",
			"        if (cnt > 0) primeCounts.push_back({p, cnt});",
			"    }",
			"    if (num > 1) primeCounts.push_back({num, 1});",
			"    return primeCounts;",
			"}"
		],
		"description": "prime_sieve"
	},
	"Hash_String": {
		"prefix": "Hash_String",
		"body": [
			"class Hash {",
			"    string str;",
			"    int n;",
			"    // utilities",
			"    vector<Mint> preHash, postHash; ",
			"    vector<Mint> powp, inv_powp;",
			"    Mint p;",
			"",
			"    public:",
			"    Hash(const string &str, const int p) {",
			"        this->str = str;",
			"        this->p = p;",
			"        this->n = str.size();",
			"        buildHash();",
			"    }",
			"",
			"    void buildHash() {",
			"        preHash.resize(n + 2, 0); // 1 based idx calculation",
			"        postHash.resize(n + 2, 0);",
			"        powp.resize(n + 2, 1);",
			"        inv_powp.resize(n + 2, 1);",
			"",
			"        inv_powp[0] = inv_powp[0].inv();",
			"        Mint invp = p.inv();",
			"",
			"        for(int i = 1 ; i <= n ; i++)",
			"            inv_powp[i] = inv_powp[i-1] * invp;",
			"        for(int i = 1 ; i <= n ; i++)",
			"            powp[i] = powp[i-1] * p;",
			"",
			"        for( int i = 0 ; i < n ; i++ ) {",
			"            preHash[i+1] = preHash[i] + (str[i] * powp[i + 1]);",
			"            postHash[n - i] = postHash[n - i + 1] + (str[n - i - 1] * powp[i + 1]);",
			"        }",
			"    }",
			"",
			"    Mint get(int l, int r, bool rev = false) {",
			"        assert((0 <= l) && (l <= r) && (r <= n - 1));",
			"        l++, r++; // 1 based indexing",
			"        if(!rev)",
			"            return (preHash[r] - preHash[l - 1]) * inv_powp[l - 1];",
			"        else ",
			"            return (postHash[l] - postHash[r + 1]) * inv_powp[n - r];",
			"    }",
			"    bool isPal(int l, int r) {",
			"        return get(l, r).val == get(l, r, true).val;",
			"    }",
			"};"
		],
		"description": "Hash_String"
	},
	"pragma_magic": {
		"prefix": "pragma_magic",
		"body": [
			"#pragma GCC optimize (\"O3\") // for c++17 ?",
			"#pragma GCC target (\"sse4\")"
		],
		"description": "pragma_magic"
	}
}
